/*
 *  File: Attempt.java      Author: Jeffery A. Solheim      Date: January, 2015
 *  Each instance represents an attempt made by a competitor to solve a Reg Ex exercise.
 *
 *  Noted weakness in this design:  assumes that all test strings must be formed over
 *  the alphabet {a,b}.  Does not, for example, allow strings over {a,b,c} or {0,1}.
 *  Possible future enhancement:  add another parameter to constructor so that
 *  user can supply alphabet as a set of char.
 *
 */

package servlet;

// ------------------------------------------
import  java.util.regex.Pattern ;
import  java.util.regex.PatternSyntaxException ;
import  java.sql.Timestamp ;
// ------------------------------------------

class Attempt
  {
  // --------------------------- instance variables ---------------------------
  private  final  int        competitorID ;
  private  final  int        exerciseID ;
  private  final  String     targetRegEx ;
  private  final  String     proposedRegEx ;
  private  final  Timestamp  timeSubmitted ;
  private  final  String     patternSyntaxMessage ; // null if no syntax error
  private  final  boolean    isSolution ;
  private  final  String     counterExample ;       //  null if a solution
  // ==========================================================================

  // ------------------------------ constructor ------------------------------
  Attempt
    (  final  int     competitorID ,
       final  int     exerciseID ,
       final  String  targetRegEx ,
       final  String  proposedRegEx   )
    {
    this.competitorID   =  competitorID ;
    this.exerciseID     =  exerciseID ;
    this.targetRegEx    =  targetRegEx ;
    this.proposedRegEx  =  proposedRegEx ;
    this.timeSubmitted  = new Timestamp ( java.util.Calendar.getInstance().getTime().getTime() ) ;

    // -------- determine the patternSyntaxMessage, if any --------
    String   initializingString  =  null ;
    Pattern  proposedPattern     =  null ;
    try
        { proposedPattern = Pattern.compile ( this.proposedRegEx ) ; }
    catch ( PatternSyntaxException pse )
        { initializingString = pse.getMessage() ; }
    this.patternSyntaxMessage  =  initializingString ;
    if ( this.patternSyntaxMessage != null )
      {
      this.isSolution     = false ;
      this.counterExample = null ;
      return ;
      }
    // ------------------------------------------------------------

    // --------------- Determine whether isSolution ---------------
    // --------- Provide counterExample if not a solution ---------
    boolean  isSolutionResult  =  true ;
    Pattern  targetPattern     =  null ;
    try
        { targetPattern = Pattern.compile ( this.targetRegEx ) ; }
    catch ( PatternSyntaxException pse )
        { System.exit(1) ; }
    // Test cases: at most 10000 strings, total, including:
    //             up to 100 strings that should match,
    //             plus up to 100 strings that should not match
    final int MAX_TESTS = 10000 ;
    final int MAX_MATCHING_TESTS = 100 ;
    final int MAX_NON_MATCHING_TESTS = 100 ;
    int    matchingTests  =  0 ;
    int    nonMatchingTests  =  0 ;
    String counterExampleString = null ;

    //String  tempString = "" ;

    // Stop testing when  ( tests >= MAX_TESTS )
    // OR  BOTH (     (matchingTests >= MAX_MATCHING_TESTS)
    //            AND (nonMatchingTests >= MAX_NON_MATCHING_TESTS) )
    for ( int testNumber = 0 ;
          (     ( testNumber < MAX_TESTS )
            &&  (    (matchingTests < MAX_MATCHING_TESTS)
             || (nonMatchingTests < MAX_NON_MATCHING_TESTS)  )  ) ;
          testNumber ++ )
      {
      int strLen = -1 ;
      int x = testNumber + 1 ;
      while ( x > 0 )
        {
        x /= 2 ;
        strLen ++ ;
        } // end while loop
      int twoToTheStrLen = 1 ;
      for ( int i = 0 ; i < strLen ; i ++ )
        twoToTheStrLen *= 2 ;

      String testString = "" ;
      if ( strLen > 0 )
        {
        testString = String.format
          (("%"+strLen+"s"), Integer.toBinaryString(testNumber + 1 - twoToTheStrLen)) ;
        testString = testString.replace ( ' ', '0' ) ;
        testString = testString.replace ( '0', 'a' ) ;
        testString = testString.replace ( '1', 'b' ) ;
        }
      //tempString += (testString + " / ") ;

      // does current testString match target Reg Ex ?
      boolean testMatchesTarget   = targetPattern.matcher(testString).matches() ;
      boolean testMatchesProposed = proposedPattern.matcher(testString).matches() ;
      boolean matchesAgree        = ( testMatchesTarget == testMatchesProposed ) ;
      if ( ! matchesAgree )
        isSolutionResult  =  false ;
      if ( testMatchesTarget && ( ! testMatchesProposed ) )
        {
        counterExampleString = ("The string \"" + testString + "\" is in the language described, but is not generated by your regular expression.") ;
	    break ; // out of for testNumber loop
        }
      else if ( ( ! testMatchesTarget ) && testMatchesProposed )
        {
        counterExampleString = ("The string \"" + testString + "\" is not in the language described, but is generated by your regular expression.") ;
	    break ; // out of for testNumber loop
        }

      if ( testMatchesTarget && (matchingTests < MAX_MATCHING_TESTS) )
        matchingTests ++ ;
      else if ( ( ! testMatchesTarget ) && (nonMatchingTests < MAX_NON_MATCHING_TESTS) )
        nonMatchingTests ++ ;
      } // end for
    this.isSolution = isSolutionResult ;
    this.counterExample = counterExampleString ;
    // ------------------------------------------------------------
	} // end constructor
  // =========================================================================

  // ------------------------------------ instance methods ------------------------------------
  synchronized int        getCompetitorID ()          {  return  this.competitorID ;          }
  synchronized int        getExerciseID ()            {  return  this.exerciseID ;            }
  synchronized String     getTargetRegEx ()           {  return  this.targetRegEx ;           }
  synchronized String     getProposedRegEx ()         {  return  this.proposedRegEx ;         }
  synchronized Timestamp  getTimeSubmitted ()         {  return  this.timeSubmitted ;         }
  synchronized String     getPatternSyntaxMessage ()  {  return  this.patternSyntaxMessage ;  }
  synchronized boolean    getIsSolution ()            {  return  this.isSolution ;            }
  synchronized String     getCounterExample ()        {  return  this.counterExample ;        }
  } // end Attempt
  // ==========================================================================================
